/** @module */
const assert = require("nanoassert");

/**
 * Parameters holds the various inputs for generating graphs.
 */
class Parameters {
  /**
   * Creates a new Parameters instance. Performs limited data validation -
   * things that should only catch programming mistakes or manual tampering.
   *
   * @param {string} transactionData
   * @param {string} transactionFileName
   * @param {Array} accounts - Every element must contain a name (string),
   *                           startingBalance (number multiplied by
   *                           utils.DECIMAL) and addToNet (boolean).
   * @param {Array} categories - Every element must contain a name (string),
   *                             descriptionPattern (string) and
   *                             counterAccountPattern (string).
   */
  constructor(transactionData, transactionFileName, accounts, categories) {
    assert(transactionData === null || typeof transactionData === "string");
    assert(
      transactionFileName === null || typeof transactionFileName === "string"
    );
    assert(Array.isArray(accounts));
    assert(accounts.length >= 1);
    for (const account of accounts) {
      assert(typeof account === "object");
      assert(typeof account.name === "string");
      assert(typeof account.startingBalance === "number");
      assert(typeof account.addToNet === "boolean");
    }
    assert(Array.isArray(categories));
    assert(categories.length >= 1);
    for (const category of categories) {
      assert(typeof category === "object");
      assert(typeof category.name === "string");
      assert(typeof category.descriptionPattern === "string");
      assert(typeof category.counterAccountPattern === "string");
    }

    this.transactionData = transactionData;
    this.transactionFileName = transactionFileName;
    this.accounts = accounts;
    this.categories = categories;
  }

  /**
   * Validates whether the parameters are correct.
   *
   * @return {null|string} Message explaining why validation failed,
   *                        or null if the data is valid.
   */
  validate() {
    if (typeof this.transactionData !== "string") {
      return "Transaction data not provided";
    }
    if (typeof this.transactionFileName !== "string") {
      return "Transaction file name not provided";
    }
    for (const account of this.accounts) {
      if (account.name === "") {
        return "An account name is empty";
      }
      if (!Number.isFinite(account.startingBalance)) {
        return `Starting balance for account ${account.name} is not a number`;
      }
    }
    for (const category of this.categories) {
      if (category.name === "") {
        return "A category name is empty";
      }
      if (category.descriptionPattern === "" && category.counterAccountPattern === "") {
        return `No description or counter-account given for category ${category.name}`;
      }
    }
    return null;
  }

  /**
   * Exports this Parameters as a JSON string.
   * @return {string} Exported string which can
   *                  be loaded using load().
   */
  export() {
    return JSON.stringify(this, null, 4);
  }

  /**
   * Imports a Parameters from a JSON string.
   * @param {string} exportString - String generated by export().
   * @return {Parameters} The resulting Parameters.
   */
  static import(exportString) {
    assert(typeof exportString === "string");
    const parsedObject = JSON.parse(exportString);

    return new Parameters(
      parsedObject.transactionData,
      parsedObject.transactionFileName,
      parsedObject.accounts,
      parsedObject.categories
    );
  }
}

exports.Parameters = Parameters;
